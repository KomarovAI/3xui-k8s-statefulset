name: Full Security & K8s Validation + Runtime Tests (Production-Ready)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  IMAGE_NAME: test-image:local
  TRIVY_VERSION: 0.50.2
  DOCKLE_VERSION: 0.4.15
  GRYPE_VERSION: 0.75.0
  SYFT_VERSION: 1.4.0
  POLARIS_VERSION: 8.5.0
  KUBECONFORM_VERSION: 0.6.4
  CONFTEST_VERSION: 0.49.0
  HADOLINT_VERSION: 2.12.0
  DIVE_VERSION: 0.12.0
  KUBESCORE_VERSION: 1.18.0

jobs:
  # ============================================
  # BUILD —Å DOCKER LAYER CACHING
  # ============================================
  build-image:
    name: 'Build Docker Image (with layer cache)'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      
      - name: Build Docker image with cache
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: ${{ env.IMAGE_NAME }}
          outputs: type=docker,dest=/tmp/image.tar
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
      
      - name: Rotate cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      
      - name: Compress image
        run: gzip -c /tmp/image.tar > image.tar.gz
      
      - name: Validate compressed image
        run: |
          SIZE=$(stat -c%s image.tar.gz 2>/dev/null || stat -f%z image.tar.gz)
          if [ "$SIZE" -lt 1000000 ]; then
            echo "‚ùå Image too small: ${SIZE} bytes (expected >1MB)"
            exit 1
          fi
          
          if ! gzip -t image.tar.gz; then
            echo "‚ùå Corrupted gzip archive"
            exit 1
          fi
          
          echo "‚úÖ Image validation passed (size: ${SIZE} bytes)"
      
      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: built-image
          path: image.tar.gz
          retention-days: 7

  # ============================================
  # SMOKE TESTS —Å FALLBACK
  # ============================================
  smoke-test:
    name: 'üî• Smoke Tests - Quick Validation'
    needs: build-image
    runs-on: self-hosted
    timeout-minutes: 5
    permissions:
      contents: read
      actions: write
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: built-image
      
      - name: Load Docker image
        run: gunzip -c image.tar.gz | docker load
      
      - name: Create test volume
        run: docker volume create smoke-test-pvc-${{ github.run_id }}
      
      - name: Run smoke test container
        run: |
          docker run -d \
            --name smoke-test-${{ github.run_id }} \
            -p 12053:2053 \
            -p 12096:2096 \
            -v smoke-test-pvc-${{ github.run_id }}:/etc/x-ui:rw \
            --health-cmd='curl -sf http://localhost:2053/ -m 5 || exit 1' \
            --health-interval=5s \
            --health-timeout=3s \
            --health-retries=3 \
            ${{ env.IMAGE_NAME }}
          
          echo "‚è≥ Waiting for container health..."
          timeout 60 sh -c 'until docker inspect --format="{{.State.Health.Status}}" smoke-test-${{ github.run_id }} | grep -q healthy; do sleep 2; done' || true
          sleep 5
      
      - name: Run all smoke tests (combined with fallback)
        run: |
          EXIT_CODE=0
          
          if docker ps | grep -q smoke-test-${{ github.run_id }}; then
            echo "‚úÖ [1/6] Container is running"
          else
            echo "‚ùå [1/6] Container failed to start"
            docker logs smoke-test-${{ github.run_id }}
            EXIT_CODE=1
          fi
          
          if docker exec smoke-test-${{ github.run_id }} pgrep -f x-ui > /dev/null 2>&1; then
            echo "‚úÖ [2/6] x-ui process is running"
          else
            echo "‚ùå [2/6] x-ui process not found"
            docker exec smoke-test-${{ github.run_id }} ps aux || true
            EXIT_CODE=1
          fi
          
          PORT_COUNT=0
          if docker exec smoke-test-${{ github.run_id }} command -v netstat > /dev/null 2>&1; then
            echo "Using netstat for port check..."
            PORT_COUNT=$(docker exec smoke-test-${{ github.run_id }} netstat -tuln 2>/dev/null | grep -E ':2053|:2096' | wc -l)
          elif docker exec smoke-test-${{ github.run_id }} command -v ss > /dev/null 2>&1; then
            echo "Using ss for port check..."
            PORT_COUNT=$(docker exec smoke-test-${{ github.run_id }} ss -tuln 2>/dev/null | grep -E ':2053|:2096' | wc -l)
          else
            echo "Fallback: using curl for port check..."
            curl -sf http://localhost:12053/ -m 2 > /dev/null 2>&1 && PORT_COUNT=$((PORT_COUNT + 1))
            curl -sf http://localhost:12096/ -m 2 > /dev/null 2>&1 && PORT_COUNT=$((PORT_COUNT + 1))
          fi
          
          if [ "$PORT_COUNT" -eq 2 ]; then
            echo "‚úÖ [3/6] Both ports listening (2053, 2096)"
          else
            echo "‚ùå [3/6] Ports not listening (found: $PORT_COUNT/2)"
            EXIT_CODE=1
          fi
          
          if curl -sf http://localhost:12053/ -m 5 > /dev/null 2>&1; then
            echo "‚úÖ [4/6] Healthcheck endpoint responsive"
          else
            echo "‚ùå [4/6] Healthcheck failed"
            docker logs smoke-test-${{ github.run_id }} --tail 50
            EXIT_CODE=1
          fi
          
          TEST_DATA="smoke-$(date +%s)"
          if docker exec smoke-test-${{ github.run_id }} bash -c "echo '$TEST_DATA' > /etc/x-ui/test.txt && cat /etc/x-ui/test.txt" 2>/dev/null | grep -q "$TEST_DATA"; then
            echo "‚úÖ [5/6] PVC is writable and readable"
            docker exec smoke-test-${{ github.run_id }} rm /etc/x-ui/test.txt 2>/dev/null || true
          else
            echo "‚ùå [5/6] PVC write/read failed"
            EXIT_CODE=1
          fi
          
          OWNER=$(docker exec smoke-test-${{ github.run_id }} stat -c '%U:%G' /etc/x-ui 2>/dev/null || echo "unknown")
          if [ "$OWNER" = "x-ui:x-ui" ]; then
            echo "‚úÖ [6/6] Correct ownership: $OWNER"
          else
            echo "‚ùå [6/6] Incorrect ownership: $OWNER (expected x-ui:x-ui)"
            EXIT_CODE=1
          fi
          
          [ $EXIT_CODE -eq 0 ] && echo -e "\nüéâ All smoke tests passed!"
          exit $EXIT_CODE
      
      - name: Export smoke test logs
        if: always()
        run: docker logs smoke-test-${{ github.run_id }} > smoke-test.log 2>&1 || true
      
      - name: Upload smoke test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-logs
          path: smoke-test.log
          retention-days: 7
      
      - name: Cleanup smoke test resources
        if: always()
        run: |
          docker stop smoke-test-${{ github.run_id }} || true
          docker rm smoke-test-${{ github.run_id }} || true
          docker volume rm smoke-test-pvc-${{ github.run_id }} || true

  # ============================================
  # HEALTH PROBES —Å RETRY LOGIC
  # ============================================
  health-probes-test:
    name: 'ü©∫ Health Probes - K8s Readiness'
    needs: smoke-test
    runs-on: self-hosted
    timeout-minutes: 10
    permissions:
      contents: read
      actions: write
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache KIND binary
        uses: actions/cache@v4
        id: cache-kind
        with:
          path: /usr/local/bin/kind
          key: ${{ runner.os }}-kind-v0.20.0
      
      - name: Install KIND
        if: steps.cache-kind.outputs.cache-hit != 'true'
        run: |
          echo "üì¶ Installing KIND..."
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind
      
      - name: Verify KIND installation
        run: echo "‚úÖ KIND version: $(kind version)"
      
      - name: Create ephemeral KIND cluster
        run: |
          CLUSTER_NAME="probe-${{ github.run_id }}"
          echo "Creating KIND cluster: $CLUSTER_NAME"
          kind create cluster --name $CLUSTER_NAME --wait 2m
      
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: built-image
      
      - name: Load image into KIND
        run: |
          gunzip -c image.tar.gz | docker load
          kind load docker-image ${{ env.IMAGE_NAME }} --name probe-${{ github.run_id }}
          echo "‚úÖ Image loaded into KIND cluster"
      
      - name: Deploy pod with health probes
        run: |
          kubectl create namespace probe-test
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: xui-probe-test
            namespace: probe-test
            labels:
              app: xui
              test: health-probes
          spec:
            containers:
            - name: xui
              image: ${{ env.IMAGE_NAME }}
              imagePullPolicy: Never
              ports:
              - containerPort: 2053
                name: http
              - containerPort: 2096
                name: secondary
              startupProbe:
                httpGet:
                  path: /
                  port: 2053
                  scheme: HTTP
                initialDelaySeconds: 5
                periodSeconds: 5
                timeoutSeconds: 3
                failureThreshold: 10
                successThreshold: 1
              livenessProbe:
                httpGet:
                  path: /
                  port: 2053
                initialDelaySeconds: 30
                periodSeconds: 10
                timeoutSeconds: 5
                failureThreshold: 3
                successThreshold: 1
              readinessProbe:
                httpGet:
                  path: /
                  port: 2053
                initialDelaySeconds: 10
                periodSeconds: 5
                timeoutSeconds: 3
                failureThreshold: 2
                successThreshold: 1
              volumeMounts:
              - name: data
                mountPath: /etc/x-ui
              securityContext:
                runAsUser: 2000
                runAsGroup: 2000
                allowPrivilegeEscalation: false
            volumes:
            - name: data
              emptyDir: {}
            securityContext:
              fsGroup: 2000
          EOF
          echo "‚úÖ Pod deployed with health probes"
      
      - name: ‚úì Test 1/4 - Startup probe succeeds
        run: |
          echo "‚è≥ Waiting for startup probe..."
          MAX_ATTEMPTS=3
          attempt=1
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            echo "Attempt $attempt/$MAX_ATTEMPTS..."
            if kubectl wait --for=condition=Started pod/xui-probe-test -n probe-test --timeout=60s 2>/dev/null; then
              echo "‚úÖ Startup probe succeeded (attempt $attempt)"
              exit 0
            fi
            [ $attempt -lt $MAX_ATTEMPTS ] && echo "‚ö†Ô∏è  Attempt $attempt failed, retrying in 10s..." && sleep 10
            attempt=$((attempt + 1))
          done
          echo "‚ùå Startup probe failed after $MAX_ATTEMPTS attempts"
          kubectl describe pod xui-probe-test -n probe-test
          kubectl logs xui-probe-test -n probe-test
          exit 1
      
      - name: ‚úì Test 2/4 - Readiness probe succeeds
        run: |
          echo "‚è≥ Waiting for readiness probe..."
          MAX_ATTEMPTS=3
          attempt=1
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            echo "Attempt $attempt/$MAX_ATTEMPTS..."
            if kubectl wait --for=condition=Ready pod/xui-probe-test -n probe-test --timeout=60s 2>/dev/null; then
              echo "‚úÖ Readiness probe succeeded (attempt $attempt)"
              exit 0
            fi
            [ $attempt -lt $MAX_ATTEMPTS ] && echo "‚ö†Ô∏è  Attempt $attempt failed, retrying in 10s..." && sleep 10
            attempt=$((attempt + 1))
          done
          echo "‚ùå Readiness probe failed after $MAX_ATTEMPTS attempts"
          kubectl describe pod xui-probe-test -n probe-test
          exit 1
      
      - name: ‚úì Test 3/4 - Liveness probe is functional
        run: |
          echo "Testing liveness probe endpoint..."
          if kubectl exec xui-probe-test -n probe-test -- curl -sf http://localhost:2053/ -m 5; then
            echo "‚úÖ Liveness probe endpoint responsive"
          else
            echo "‚ùå Liveness probe endpoint not responding"
            exit 1
          fi
          LIVENESS_STATUS=$(kubectl get pod xui-probe-test -n probe-test -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}')
          if [ "$LIVENESS_STATUS" = "True" ]; then
            echo "‚úÖ Pod reports healthy state"
          else
            echo "‚ùå Pod state unhealthy: $LIVENESS_STATUS"
            exit 1
          fi
      
      - name: ‚úì Test 4/4 - Graceful shutdown
        run: |
          echo "Testing graceful shutdown..."
          START_TIME=$(date +%s)
          kubectl delete pod xui-probe-test -n probe-test --grace-period=30 &
          DELETE_PID=$!
          if wait $DELETE_PID; then
            END_TIME=$(date +%s)
            DURATION=$((END_TIME - START_TIME))
            if [ $DURATION -le 35 ]; then
              echo "‚úÖ Graceful shutdown: ${DURATION}s (within grace period)"
            else
              echo "‚ö†Ô∏è  Shutdown took ${DURATION}s (exceeded 30s grace period)"
            fi
          else
            echo "‚ùå Graceful shutdown failed"
            exit 1
          fi
      
      - name: Export health probe logs
        if: always()
        run: |
          kubectl logs xui-probe-test -n probe-test --previous > health-probe-previous.log 2>&1 || true
          kubectl logs xui-probe-test -n probe-test > health-probe-current.log 2>&1 || true
          kubectl describe pod xui-probe-test -n probe-test > health-probe-describe.log 2>&1 || true
          kubectl get events -n probe-test --sort-by='.lastTimestamp' > health-probe-events.log 2>&1 || true
      
      - name: Upload health probe artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-probe-logs
          path: health-probe-*.log
          retention-days: 7
      
      - name: Cleanup KIND cluster
        if: always()
        run: kind delete cluster --name probe-${{ github.run_id }} || true

  # ============================================
  # STATIC ANALYSIS (NON-BLOCKING)
  # ============================================
  hadolint-lint:
    name: 'Hadolint - Dockerfile Optimization'
    needs: build-image
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Cache Hadolint
        uses: actions/cache@v4
        id: cache-hadolint
        with:
          path: /usr/local/bin/hadolint
          key: hadolint-${{ env.HADOLINT_VERSION }}
      - name: Install Hadolint
        if: steps.cache-hadolint.outputs.cache-hit != 'true'
        run: |
          wget -O hadolint https://github.com/hadolint/hadolint/releases/download/v${{ env.HADOLINT_VERSION }}/hadolint-Linux-x86_64
          chmod +x hadolint
          sudo mv hadolint /usr/local/bin/
      - name: Run Hadolint
        run: hadolint Dockerfile > hadolint.log || echo "‚ö†Ô∏è  Hadolint found issues (non-blocking)"
      - name: Upload Hadolint RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-hadolint
          path: hadolint.log
          retention-days: 7

  dive-analysis:
    name: 'Dive - Image Efficiency'
    needs: build-image
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: built-image
      - name: Load Docker image
        run: gunzip -c image.tar.gz | docker load
      - name: Cache Dive
        uses: actions/cache@v4
        id: cache-dive
        with:
          path: /usr/local/bin/dive
          key: dive-${{ env.DIVE_VERSION }}
      - name: Install Dive
        if: steps.cache-dive.outputs.cache-hit != 'true'
        run: |
          wget https://github.com/wagoodman/dive/releases/download/v${{ env.DIVE_VERSION }}/dive_${{ env.DIVE_VERSION }}_linux_amd64.tar.gz
          tar -xzf dive_${{ env.DIVE_VERSION }}_linux_amd64.tar.gz
          sudo mv dive /usr/local/bin/
      - name: Run Dive
        run: CI=true dive ${{ env.IMAGE_NAME }} --ci > dive.log || echo "‚ö†Ô∏è  Dive found issues (non-blocking)"
      - name: Upload Dive RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-dive
          path: dive.log
          retention-days: 7

  kube-score:
    name: 'Kube-Score - K8s Best Practices'
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Cache kube-score
        uses: actions/cache@v4
        id: cache-kubescore
        with:
          path: /usr/local/bin/kube-score
          key: kubescore-${{ env.KUBESCORE_VERSION }}
      - name: Install kube-score
        if: steps.cache-kubescore.outputs.cache-hit != 'true'
        run: |
          wget https://github.com/zegl/kube-score/releases/download/v${{ env.KUBESCORE_VERSION }}/kube-score_${{ env.KUBESCORE_VERSION }}_linux_amd64.tar.gz
          tar -xzf kube-score_${{ env.KUBESCORE_VERSION }}_linux_amd64.tar.gz
          sudo mv kube-score /usr/local/bin/
      - name: Run kube-score
        run: |
          if [ -d "manifests" ]; then
            kube-score score manifests/*.yaml --output-format ci > kube-score.log || echo "‚ö†Ô∏è  Kube-score found issues (non-blocking)"
          else
            echo 'No manifests/ for analysis' > kube-score.log
          fi
      - name: Upload Kube-Score RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-kubescore
          path: kube-score.log
          retention-days: 7

  trivy-scan:
    name: 'Trivy - CVE Scan'
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Cache Trivy
        uses: actions/cache@v4
        id: cache-trivy
        with:
          path: /usr/local/bin/trivy
          key: trivy-${{ env.TRIVY_VERSION }}
      - name: Install Trivy
        if: steps.cache-trivy.outputs.cache-hit != 'true'
        run: |
          wget -qO- https://github.com/aquasecurity/trivy/releases/download/v${{ env.TRIVY_VERSION }}/trivy_${{ env.TRIVY_VERSION }}_Linux-64bit.tar.gz | tar xz
          sudo mv trivy /usr/local/bin/
      - name: Run Trivy
        run: trivy config Dockerfile > trivy.log || echo "‚ö†Ô∏è  Trivy found issues (non-blocking)"
      - name: Upload Trivy RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-trivy
          path: trivy.log
          retention-days: 7

  dockle-scan:
    name: 'Dockle - Docker Hardening'
    needs: build-image
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Cache Dockle
        uses: actions/cache@v4
        id: cache-dockle
        with:
          path: /usr/local/bin/dockle
          key: dockle-${{ env.DOCKLE_VERSION }}
      - name: Install Dockle
        if: steps.cache-dockle.outputs.cache-hit != 'true'
        run: |
          wget -O - https://github.com/goodwithtech/dockle/releases/download/v${{ env.DOCKLE_VERSION }}/dockle_${{ env.DOCKLE_VERSION }}_Linux-64bit.tar.gz | tar xz
          sudo mv dockle /usr/local/bin/
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: built-image
      - name: Load Docker image
        run: gunzip -c image.tar.gz | docker load
      - name: Run Dockle
        run: dockle ${{ env.IMAGE_NAME }} > dockle.log || echo "‚ö†Ô∏è  Dockle found issues (non-blocking)"
      - name: Upload Dockle RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-dockle
          path: dockle.log
          retention-days: 7

  grype-scan:
    name: 'Grype - Vulnerability Scan'
    needs: build-image
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Cache Grype
        uses: actions/cache@v4
        id: cache-grype
        with:
          path: /usr/local/bin/grype
          key: grype-${{ env.GRYPE_VERSION }}
      - name: Install Grype
        if: steps.cache-grype.outputs.cache-hit != 'true'
        run: |
          wget -O- https://github.com/anchore/grype/releases/download/v${{ env.GRYPE_VERSION }}/grype_${{ env.GRYPE_VERSION }}_linux_amd64.tar.gz | tar xz
          sudo mv grype /usr/local/bin/
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: built-image
      - name: Load Docker image
        run: gunzip -c image.tar.gz | docker load
      - name: Run Grype
        run: grype ${{ env.IMAGE_NAME }} > grype.log || echo "‚ö†Ô∏è  Grype found issues (non-blocking)"
      - name: Upload Grype RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-grype
          path: grype.log
          retention-days: 7

  syft-sbom:
    name: 'Syft - SBOM Generation'
    needs: build-image
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Cache Syft
        uses: actions/cache@v4
        id: cache-syft
        with:
          path: /usr/local/bin/syft
          key: syft-${{ env.SYFT_VERSION }}
      - name: Install Syft
        if: steps.cache-syft.outputs.cache-hit != 'true'
        run: |
          wget -O- https://github.com/anchore/syft/releases/download/v${{ env.SYFT_VERSION }}/syft_${{ env.SYFT_VERSION }}_linux_amd64.tar.gz | tar xz
          sudo mv syft /usr/local/bin/
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: built-image
      - name: Load Docker image
        run: gunzip -c image.tar.gz | docker load
      - name: Generate SBOM
        run: syft ${{ env.IMAGE_NAME }} -o spdx-json > syft.log || echo "‚ö†Ô∏è  Syft generation issues (non-blocking)"
      - name: Upload Syft RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-syft
          path: syft.log
          retention-days: 7

  polaris-score:
    name: 'Polaris - Policy Enforcement'
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Cache Polaris
        uses: actions/cache@v4
        id: cache-polaris
        with:
          path: /usr/local/bin/polaris
          key: polaris-${{ env.POLARIS_VERSION }}
      - name: Install Polaris
        if: steps.cache-polaris.outputs.cache-hit != 'true'
        run: |
          wget -O- https://github.com/FairwindsOps/polaris/releases/download/${{ env.POLARIS_VERSION }}/polaris_linux_amd64.tar.gz | tar xz
          sudo mv polaris /usr/local/bin/
      - name: Run Polaris
        run: |
          if [ -d "manifests" ]; then
            polaris audit --audit-path manifests > polaris.log || echo "‚ö†Ô∏è  Polaris found issues (non-blocking)"
          else
            echo 'No manifests/ for analysis' > polaris.log
          fi
      - name: Upload Polaris RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-polaris
          path: polaris.log
          retention-days: 7

  kubeconform-validate:
    name: 'Kubeconform - YAML Validation'
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Cache Kubeconform
        uses: actions/cache@v4
        id: cache-kubeconform
        with:
          path: /usr/local/bin/kubeconform
          key: kubeconform-${{ env.KUBECONFORM_VERSION }}
      - name: Install Kubeconform
        if: steps.cache-kubeconform.outputs.cache-hit != 'true'
        run: |
          wget https://github.com/yannh/kubeconform/releases/download/v${{ env.KUBECONFORM_VERSION }}/kubeconform-linux-amd64.tar.gz
          tar -xzf kubeconform-linux-amd64.tar.gz
          chmod +x kubeconform
          sudo mv kubeconform /usr/local/bin/
      - name: Validate manifests
        run: |
          if [ -d "manifests" ]; then
            kubeconform -strict -summary manifests/*.yaml > kubeconform.log || echo "‚ö†Ô∏è  Kubeconform found issues (non-blocking)"
          else
            echo 'No manifests/ for analysis' > kubeconform.log
          fi
      - name: Upload Kubeconform RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-kubeconform
          path: kubeconform.log
          retention-days: 7

  conftest-policy:
    name: 'Conftest - OPA Policy'
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Cache Conftest
        uses: actions/cache@v4
        id: cache-conftest
        with:
          path: /usr/local/bin/conftest
          key: conftest-${{ env.CONFTEST_VERSION }}
      - name: Install Conftest
        if: steps.cache-conftest.outputs.cache-hit != 'true'
        run: |
          wget https://github.com/open-policy-agent/conftest/releases/download/v${{ env.CONFTEST_VERSION }}/conftest_${{ env.CONFTEST_VERSION }}_Linux_x86_64.tar.gz
          tar -xzf conftest_${{ env.CONFTEST_VERSION }}_Linux_x86_64.tar.gz
          chmod +x conftest
          sudo mv conftest /usr/local/bin/
      - name: Run Conftest
        run: |
          if [ -d "policies" ] && [ -d "manifests" ]; then
            conftest test manifests/*.yaml > conftest.log || echo "‚ö†Ô∏è  Conftest found issues (non-blocking)"
          else
            echo 'No policies/ or manifests/ for analysis' > conftest.log
          fi
      - name: Upload Conftest RAW
        uses: actions/upload-artifact@v4
        with:
          name: raw-conftest
          path: conftest.log
          retention-days: 7

  # ============================================
  # UNIFIED SUMMARY REPORT
  # ============================================
  summary:
    name: 'Workflow Final Status'
    needs: [hadolint-lint, dive-analysis, kube-score, trivy-scan, dockle-scan, grype-scan, syft-sbom, polaris-score, kubeconform-validate, conftest-policy, smoke-test, health-probes-test]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: read
      actions: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
      
      - name: Generate unified debug report
        run: |
          cat > UNIFIED_REPORT.txt << 'EOF'
          ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
          ‚ïë           CI/CD PIPELINE EXECUTION REPORT                     ‚ïë
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
          EOF
          echo "" >> UNIFIED_REPORT.txt
          echo "Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> UNIFIED_REPORT.txt
          echo "Workflow: ${{ github.workflow }}" >> UNIFIED_REPORT.txt
          echo "Run ID: ${{ github.run_id }}" >> UNIFIED_REPORT.txt
          echo "Commit: ${{ github.sha }}" >> UNIFIED_REPORT.txt
          echo "Branch: ${{ github.ref_name }}" >> UNIFIED_REPORT.txt
          echo "Actor: ${{ github.actor }}" >> UNIFIED_REPORT.txt
          echo "" >> UNIFIED_REPORT.txt
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> UNIFIED_REPORT.txt
          echo "" >> UNIFIED_REPORT.txt
          
          total_jobs=12
          passed=0
          failed=0
          warnings=0
          critical_failed=0
          
          smoke_status="${{ needs.smoke-test.result }}"
          health_status="${{ needs.health-probes-test.result }}"
          
          [[ "$smoke_status" == "success" ]] && passed=$((passed + 1)) || { failed=$((failed + 1)); critical_failed=$((critical_failed + 1)); }
          [[ "$health_status" == "success" ]] && passed=$((passed + 1)) || { failed=$((failed + 1)); critical_failed=$((critical_failed + 1)); }
          
          for status in "${{ needs.hadolint-lint.result }}" "${{ needs.dive-analysis.result }}" "${{ needs.kube-score.result }}" "${{ needs.trivy-scan.result }}" "${{ needs.dockle-scan.result }}" "${{ needs.grype-scan.result }}" "${{ needs.syft-sbom.result }}" "${{ needs.polaris-score.result }}" "${{ needs.kubeconform-validate.result }}" "${{ needs.conftest-policy.result }}"; do
            [[ "$status" == "success" ]] && passed=$((passed + 1)) || warnings=$((warnings + 1))
          done
          
          echo "## üìä EXECUTIVE SUMMARY" >> UNIFIED_REPORT.txt
          echo "" >> UNIFIED_REPORT.txt
          echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê" >> UNIFIED_REPORT.txt
          echo "‚îÇ Total Jobs: $total_jobs" >> UNIFIED_REPORT.txt
          echo "‚îÇ ‚úÖ Passed: $passed" >> UNIFIED_REPORT.txt
          echo "‚îÇ ‚ùå Failed (Critical): $critical_failed" >> UNIFIED_REPORT.txt
          echo "‚îÇ ‚ö†Ô∏è  Warnings (Non-blocking): $warnings" >> UNIFIED_REPORT.txt
          echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò" >> UNIFIED_REPORT.txt
          echo "" >> UNIFIED_REPORT.txt
          
          if [[ $critical_failed -gt 0 ]]; then
            echo "üö´ STATUS: DEPLOYMENT BLOCKED" >> UNIFIED_REPORT.txt
          elif [[ $warnings -gt 0 ]]; then
            echo "‚ö†Ô∏è  STATUS: PASSED WITH WARNINGS" >> UNIFIED_REPORT.txt
          else
            echo "‚úÖ STATUS: ALL CHECKS PASSED" >> UNIFIED_REPORT.txt
          fi
          
          echo "" >> UNIFIED_REPORT.txt
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> UNIFIED_REPORT.txt
          echo "" >> UNIFIED_REPORT.txt
          
          if [[ $critical_failed -gt 0 ]]; then
            echo "## üî¥ CRITICAL FAILURES (BLOCKING)" >> UNIFIED_REPORT.txt
            echo "" >> UNIFIED_REPORT.txt
            
            if [[ "$smoke_status" != "success" ]]; then
              echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê" >> UNIFIED_REPORT.txt
              echo "‚îÇ ‚ùå SMOKE TESTS FAILED" >> UNIFIED_REPORT.txt
              echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò" >> UNIFIED_REPORT.txt
              echo "" >> UNIFIED_REPORT.txt
              [ -f "smoke-test-logs/smoke-test.log" ] && tail -n 100 smoke-test-logs/smoke-test.log >> UNIFIED_REPORT.txt
              echo "" >> UNIFIED_REPORT.txt
              echo "### Debug Commands:" >> UNIFIED_REPORT.txt
              echo "docker run -d --name test-xui -p 2053:2053 test-image:local" >> UNIFIED_REPORT.txt
              echo "docker logs test-xui" >> UNIFIED_REPORT.txt
              echo "curl -v http://localhost:2053/" >> UNIFIED_REPORT.txt
              echo "" >> UNIFIED_REPORT.txt
            fi
            
            if [[ "$health_status" != "success" ]]; then
              echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê" >> UNIFIED_REPORT.txt
              echo "‚îÇ ‚ùå HEALTH PROBES FAILED" >> UNIFIED_REPORT.txt
              echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò" >> UNIFIED_REPORT.txt
              echo "" >> UNIFIED_REPORT.txt
              [ -f "health-probe-logs/health-probe-current.log" ] && tail -n 50 health-probe-logs/health-probe-current.log >> UNIFIED_REPORT.txt
              [ -f "health-probe-logs/health-probe-describe.log" ] && cat health-probe-logs/health-probe-describe.log >> UNIFIED_REPORT.txt
              echo "" >> UNIFIED_REPORT.txt
            fi
          fi
          
          if [[ $warnings -gt 0 ]]; then
            echo "## ‚ö†Ô∏è  WARNINGS (NON-BLOCKING)" >> UNIFIED_REPORT.txt
            echo "" >> UNIFIED_REPORT.txt
            for job in hadolint dive kube-score trivy dockle grype syft polaris kubeconform conftest; do
              log_dir="raw-${job}"*
              [ -d "$log_dir" ] && echo "‚îå‚îÄ $job ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê" >> UNIFIED_REPORT.txt && tail -n 30 "$log_dir"/* >> UNIFIED_REPORT.txt 2>/dev/null && echo "" >> UNIFIED_REPORT.txt
            done
          fi
          
          echo "## ‚úÖ PASSED CHECKS" >> UNIFIED_REPORT.txt
          echo "" >> UNIFIED_REPORT.txt
          [[ "$smoke_status" == "success" ]] && echo "‚úÖ Smoke Tests" >> UNIFIED_REPORT.txt
          [[ "$health_status" == "success" ]] && echo "‚úÖ Health Probes" >> UNIFIED_REPORT.txt
          echo "" >> UNIFIED_REPORT.txt
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> UNIFIED_REPORT.txt
          echo "" >> UNIFIED_REPORT.txt
          echo "üîó Workflow Run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> UNIFIED_REPORT.txt
          echo "Report size: $(wc -c < UNIFIED_REPORT.txt) bytes" >> UNIFIED_REPORT.txt
      
      - name: Upload unified report
        uses: actions/upload-artifact@v4
        with:
          name: UNIFIED_REPORT
          path: UNIFIED_REPORT.txt
          retention-days: 30
      
      - name: Show GitHub Summary
        run: |
          echo "# üîç Pipeline Execution Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          critical_failed=0
          warnings=0
          passed=0
          
          smoke_status="${{ needs.smoke-test.result }}"
          health_status="${{ needs.health-probes-test.result }}"
          
          [[ "$smoke_status" != "success" ]] && critical_failed=$((critical_failed + 1))
          [[ "$health_status" != "success" ]] && critical_failed=$((critical_failed + 1))
          [[ "$smoke_status" == "success" ]] && passed=$((passed + 1))
          [[ "$health_status" == "success" ]] && passed=$((passed + 1))
          
          for status in "${{ needs.hadolint-lint.result }}" "${{ needs.dive-analysis.result }}" "${{ needs.kube-score.result }}" "${{ needs.trivy-scan.result }}" "${{ needs.dockle-scan.result }}" "${{ needs.grype-scan.result }}" "${{ needs.syft-sbom.result }}" "${{ needs.polaris-score.result }}" "${{ needs.kubeconform-validate.result }}" "${{ needs.conftest-policy.result }}"; do
            [[ "$status" == "success" ]] && passed=$((passed + 1)) || warnings=$((warnings + 1))
          done
          
          echo "## üìä Quick Stats" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| ‚úÖ Passed | $passed |" >> $GITHUB_STEP_SUMMARY
          echo "| ‚ùå Critical Failed | $critical_failed |" >> $GITHUB_STEP_SUMMARY
          echo "| ‚ö†Ô∏è  Warnings | $warnings |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ $critical_failed -gt 0 ]]; then
            echo "## üö´ Deployment Blocked" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Critical tests failed. Review UNIFIED_REPORT.txt for details.**" >> $GITHUB_STEP_SUMMARY
            [[ "$smoke_status" != "success" ]] && echo "- ‚ùå Smoke Tests failed" >> $GITHUB_STEP_SUMMARY
            [[ "$health_status" != "success" ]] && echo "- ‚ùå Health Probes failed" >> $GITHUB_STEP_SUMMARY
          elif [[ $warnings -gt 0 ]]; then
            echo "## ‚ö†Ô∏è  Passed with Warnings" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**$warnings warnings detected. Review recommended.**" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚úÖ All Checks Passed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Image ready for production deployment! üöÄ**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìÑ **Full Report**: Download \`UNIFIED_REPORT.txt\` artifact" >> $GITHUB_STEP_SUMMARY
          
          [[ $critical_failed -gt 0 ]] && exit 1 || exit 0
