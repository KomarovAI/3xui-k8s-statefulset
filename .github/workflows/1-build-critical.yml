name: "âš¡ Critical Path: Build & Runtime Tests"

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

# Cancel redundant runs
concurrency:
  group: critical-${{ github.ref }}
  cancel-in-progress: true

env:
  IMAGE_NAME: test-image:local

jobs:
  build-image:
    name: 'Build Docker Image'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v6
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      
      - name: Build Docker image
        id: build
        timeout-minutes: 15
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: ${{ env.IMAGE_NAME }}
          outputs: type=docker,dest=/tmp/image.tar
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
      
      - name: Rotate cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      
      - name: Compress & validate image
        run: |
          gzip -c /tmp/image.tar > image.tar.gz
          SIZE=$(stat -c%s image.tar.gz 2>/dev/null || stat -f%z image.tar.gz)
          echo "ðŸ“¦ Image size: $SIZE bytes"
          [ "$SIZE" -lt 1000000 ] && echo "âŒ Image too small" && exit 1
          gzip -t image.tar.gz || { echo "âŒ Corrupted archive"; exit 1; }
          echo "âœ… Image validation passed"
      
      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ github.sha }}
          path: image.tar.gz
          retention-days: 7
      
      - name: Cache image for other workflows
        uses: actions/cache@v4
        with:
          path: image.tar.gz
          key: docker-image-${{ github.sha }}

  smoke-test:
    name: 'ðŸ”¥ Smoke Tests'
    needs: build-image
    # Smart runner selection: PRs use GitHub-hosted, main uses self-hosted
    runs-on: ${{ github.event_name == 'pull_request' && 'ubuntu-latest' || 'self-hosted' }}
    timeout-minutes: 5
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v6
      
      - name: Download Docker image
        timeout-minutes: 3
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ github.sha }}
      
      - name: Load & run container with dynamic ports
        run: |
          gunzip -c image.tar.gz | docker load
          docker volume create smoke-test-pvc-${{ github.run_id }}
          
          # Use dynamic port allocation to prevent conflicts
          docker run -d \
            --name smoke-test-${{ github.run_id }} \
            -p 0:2053 \
            -p 0:2096 \
            -v smoke-test-pvc-${{ github.run_id }}:/etc/x-ui:rw \
            --health-cmd='curl -sf http://localhost:2053/ -m 5 || exit 1' \
            --health-interval=5s \
            --health-timeout=3s \
            --health-retries=3 \
            ${{ env.IMAGE_NAME }}
          
          # Wait for healthy status
          timeout 60 sh -c 'until docker inspect --format="{{.State.Health.Status}}" smoke-test-${{ github.run_id }} | grep -q healthy; do sleep 2; done'
          sleep 5
          
          # Get dynamically assigned ports
          PRIMARY_PORT=$(docker port smoke-test-${{ github.run_id }} 2053 | cut -d: -f2)
          SECONDARY_PORT=$(docker port smoke-test-${{ github.run_id }} 2096 | cut -d: -f2)
          echo "PRIMARY_PORT=${PRIMARY_PORT}" >> $GITHUB_ENV
          echo "SECONDARY_PORT=${SECONDARY_PORT}" >> $GITHUB_ENV
          echo "ðŸ”Œ Ports: $PRIMARY_PORT, $SECONDARY_PORT"
      
      - name: Run smoke tests
        timeout-minutes: 3
        run: |
          EXIT_CODE=0
          
          # Test 1: Container running
          docker ps | grep -q smoke-test-${{ github.run_id }} || { 
            echo "âŒ Container not running"
            docker ps -a | grep smoke-test || true
            EXIT_CODE=1
          }
          
          # Test 2: Process running
          docker exec smoke-test-${{ github.run_id }} pgrep -f x-ui >/dev/null 2>&1 || { 
            echo "âŒ x-ui process not found"
            docker exec smoke-test-${{ github.run_id }} ps aux || true
            EXIT_CODE=1
          }
          
          # Test 3: Ports listening (using dynamic ports)
          PORT_COUNT=0
          curl -sf http://localhost:${PRIMARY_PORT}/ -m 2 >/dev/null && PORT_COUNT=$((PORT_COUNT + 1))
          curl -sf http://localhost:${SECONDARY_PORT}/ -m 2 >/dev/null && PORT_COUNT=$((PORT_COUNT + 1))
          [ "$PORT_COUNT" -eq 2 ] || { echo "âŒ Ports not listening (found: $PORT_COUNT/2)"; EXIT_CODE=1; }
          
          # Test 4: Healthcheck
          curl -sf http://localhost:${PRIMARY_PORT}/ -m 5 >/dev/null || { 
            echo "âŒ Healthcheck failed"
            docker logs smoke-test-${{ github.run_id }} | tail -n 50
            EXIT_CODE=1
          }
          
          # Test 5: PVC writable
          TEST_DATA="smoke-$(date +%s)"
          docker exec smoke-test-${{ github.run_id }} bash -c "echo '$TEST_DATA' > /etc/x-ui/test.txt && cat /etc/x-ui/test.txt" | grep -q "$TEST_DATA" || { 
            echo "âŒ PVC not writable"
            EXIT_CODE=1
          }
          
          # Test 6: Ownership
          OWNER=$(docker exec smoke-test-${{ github.run_id }} stat -c '%U:%G' /etc/x-ui 2>/dev/null)
          [ "$OWNER" = "x-ui:x-ui" ] || { echo "âŒ Wrong ownership: $OWNER"; EXIT_CODE=1; }
          
          [ $EXIT_CODE -eq 0 ] && echo "ðŸŽ‰ All smoke tests passed!"
          exit $EXIT_CODE
      
      - name: Export logs
        if: always()
        run: docker logs smoke-test-${{ github.run_id }} > smoke-test.log 2>&1 || true
      
      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-logs-${{ github.sha }}
          path: smoke-test.log
      
      - name: Cleanup
        if: always()
        run: |
          docker stop smoke-test-${{ github.run_id }} || true
          docker rm smoke-test-${{ github.run_id }} || true
          docker volume rm smoke-test-pvc-${{ github.run_id }} || true

  health-probes-test:
    name: 'ðŸ©º Health Probes - K8s Readiness'
    needs: build-image
    # Smart runner selection
    runs-on: ${{ github.event_name == 'pull_request' && 'ubuntu-latest' || 'self-hosted' }}
    timeout-minutes: 10
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v6
      
      - name: Cache KIND binary
        uses: actions/cache@v4
        id: cache-kind
        with:
          path: /usr/local/bin/kind
          key: ${{ runner.os }}-kind-v0.20.0
      
      - name: Install KIND
        if: steps.cache-kind.outputs.cache-hit != 'true'
        run: |
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind
      
      - name: Create KIND cluster
        timeout-minutes: 3
        run: |
          CLUSTER_NAME="probe-${{ github.run_id }}"
          kind create cluster --name $CLUSTER_NAME --wait 2m
      
      - name: Download & load image
        timeout-minutes: 3
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ github.sha }}
      
      - name: Load image into KIND
        run: |
          gunzip -c image.tar.gz | docker load
          kind load docker-image ${{ env.IMAGE_NAME }} --name probe-${{ github.run_id }}
      
      - name: Deploy pod with health probes
        run: |
          kubectl create namespace probe-test
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: xui-probe-test
            namespace: probe-test
          spec:
            containers:
            - name: xui
              image: ${{ env.IMAGE_NAME }}
              imagePullPolicy: Never
              ports:
              - containerPort: 2053
              startupProbe:
                httpGet:
                  path: /
                  port: 2053
                initialDelaySeconds: 5
                periodSeconds: 5
                timeoutSeconds: 3
                failureThreshold: 10
              livenessProbe:
                httpGet:
                  path: /
                  port: 2053
                initialDelaySeconds: 30
                periodSeconds: 10
                timeoutSeconds: 5
                failureThreshold: 3
              readinessProbe:
                httpGet:
                  path: /
                  port: 2053
                initialDelaySeconds: 10
                periodSeconds: 5
                timeoutSeconds: 3
                failureThreshold: 2
              volumeMounts:
              - name: data
                mountPath: /etc/x-ui
              securityContext:
                runAsUser: 2000
                runAsGroup: 2000
                allowPrivilegeEscalation: false
            volumes:
            - name: data
              emptyDir: {}
          EOF
      
      - name: Test startup probe
        run: |
          for i in {1..3}; do
            kubectl wait --for=condition=Started pod/xui-probe-test -n probe-test --timeout=60s && exit 0
            [ $i -lt 3 ] && sleep 10
          done
          kubectl describe pod xui-probe-test -n probe-test
          exit 1
      
      - name: Test readiness probe
        run: kubectl wait --for=condition=Ready pod/xui-probe-test -n probe-test --timeout=60s
      
      - name: Test liveness probe
        run: |
          kubectl exec xui-probe-test -n probe-test -- curl -sf http://localhost:2053/ -m 5
          LIVENESS=$(kubectl get pod xui-probe-test -n probe-test -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}')
          [ "$LIVENESS" = "True" ] || exit 1
      
      - name: Test graceful shutdown
        run: |
          START=$(date +%s)
          kubectl delete pod xui-probe-test -n probe-test --grace-period=30
          END=$(date +%s)
          DURATION=$((END - START))
          echo "Shutdown duration: ${DURATION}s"
          [ $DURATION -le 35 ] || echo "âš ï¸ Shutdown took longer than grace period"
      
      - name: Export logs
        if: always()
        run: |
          kubectl logs xui-probe-test -n probe-test > health-probe.log 2>&1 || true
          kubectl describe pod xui-probe-test -n probe-test > health-probe-describe.log 2>&1 || true
      
      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-probe-logs-${{ github.sha }}
          path: health-probe*.log
      
      - name: Cleanup
        if: always()
        run: kind delete cluster --name probe-${{ github.run_id }} || true

  critical-summary:
    name: 'âœ… Critical Path Status'
    needs: [smoke-test, health-probes-test]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Check critical failures
        run: |
          SMOKE="${{ needs.smoke-test.result }}"
          HEALTH="${{ needs.health-probes-test.result }}"
          
          echo "# ðŸš¨ Critical Path Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          
          if [ "$SMOKE" = "success" ]; then
            echo "| ðŸ”¥ Smoke Tests | âœ… PASSED |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ”¥ Smoke Tests | âŒ FAILED |" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "$HEALTH" = "success" ]; then
            echo "| ðŸ©º Health Probes | âœ… PASSED |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ©º Health Probes | âŒ FAILED |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$SMOKE" != "success" ] || [ "$HEALTH" != "success" ]; then
            echo "## ðŸš« DEPLOYMENT BLOCKED" >> $GITHUB_STEP_SUMMARY
            echo "Critical tests failed. Review logs for details." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          echo "## âœ… READY FOR DEPLOYMENT" >> $GITHUB_STEP_SUMMARY
          echo "All critical tests passed! ðŸš€" >> $GITHUB_STEP_SUMMARY
